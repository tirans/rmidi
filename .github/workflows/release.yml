name: Production Release
on:
  workflow_run:
    workflows: ["Build and Test"]
    types: [completed]
    branches: [master]

permissions:
  contents: write
  id-token: write

jobs:
  check-build-success:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      should_app_store: ${{ steps.check.outputs.should_app_store }}
      version: ${{ steps.get_version.outputs.version }}
      build_status: ${{ steps.check_build_status.outputs.build_status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Check build status
        id: check_build_status
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
            echo "build_status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Previous build was successful"
          else
            echo "build_status=failure" >> $GITHUB_OUTPUT
            echo "‚ùå Previous build failed - will create a release anyway"
          fi

      - name: Check if release needed
        id: check
        run: |
          # Check if we have signing certificates (only macOS required now)
          if [ -n "${{ secrets.APPLE_CERTIFICATE_P12 }}" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "‚úÖ macOS code signing certificates available - proceeding with release"
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No macOS signing certificates available - skipping signed release"
          fi

          # Check if we should submit to App Store
          if [ -n "${{ secrets.APP_STORE_CONNECT_API_KEY }}" ] && [ -n "${{ secrets.APPLE_APP_STORE_CERTIFICATE_P12 }}" ]; then
            echo "should_app_store=true" >> $GITHUB_OUTPUT
            echo "üè™ App Store Connect API key and certificates available - will submit to App Store"
          else
            echo "should_app_store=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è App Store submission disabled (missing API key or certificates)"
          fi

      - name: Get version
        id: get_version
        run: |
          VERSION=$(grep -o '__version__ = "[^"]*"' server/version.py | cut -d'"' -f2)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  code-sign-and-package:
    needs: check-build-success
    if: needs.check-build-success.outputs.should_release == 'true'
    strategy:
      fail-fast: false
      matrix:
        os: [macos-13, windows-latest, ubuntu-latest]
        include:
          - os: macos-13
            platform: macOS
            platform_name: macos
          - os: windows-latest
            platform: windows
            platform_name: windows
          - os: ubuntu-latest
            platform: linux
            platform_name: linux
    runs-on: ${{ matrix.os }}
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Fix submodules
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git submodule deinit -f server/midi-presets || true
          rm -rf .git/modules/server/midi-presets || true
          git rm -rf server/midi-presets || true
          git submodule add https://github.com/tirans/midi-presets.git server/midi-presets
          git submodule init
          git submodule update --init --recursive
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Configure app metadata
        env:
          BUNDLE_PREFIX: ${{ secrets.APP_BUNDLE_ID_PREFIX }}
          SERVER_NAME: ${{ secrets.APP_DISPLAY_NAME_SERVER }}
          CLIENT_NAME: ${{ secrets.APP_DISPLAY_NAME_CLIENT }}
          AUTHOR_NAME: ${{ secrets.APP_AUTHOR_NAME }}
          AUTHOR_EMAIL: ${{ secrets.APP_AUTHOR_EMAIL }}
        run: |
          echo "BUNDLE_PREFIX=${BUNDLE_PREFIX:-com.r2midi}" >> $GITHUB_ENV
          echo "SERVER_NAME=${SERVER_NAME:-R2MIDI Server}" >> $GITHUB_ENV
          echo "CLIENT_NAME=${CLIENT_NAME:-R2MIDI Client}" >> $GITHUB_ENV
          echo "AUTHOR_NAME=${AUTHOR_NAME:-R2MIDI Team}" >> $GITHUB_ENV
          echo "AUTHOR_EMAIL=${AUTHOR_EMAIL:-tiran@tirans.com}" >> $GITHUB_ENV

          VERSION=$(grep -o '__version__ = "[^"]*"' server/version.py | cut -d'"' -f2)
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Import Code Signing Certificates (macOS)
        if: matrix.platform == 'macOS'
        env:
          APPLE_CERTIFICATE_P12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          if [ -z "$APPLE_CERTIFICATE_P12" ]; then
            echo "‚ùå No macOS signing certificates provided"
            exit 1
          fi

          # Mask sensitive values in logs
          echo "::add-mask::$APPLE_CERTIFICATE_PASSWORD"

          security create-keychain -p temp_password temp.keychain
          security default-keychain -s temp.keychain
          security unlock-keychain -p temp_password temp.keychain

          # Import certificate with error handling
          echo "$APPLE_CERTIFICATE_P12" | base64 --decode > developer_id_cert.p12
          security import developer_id_cert.p12 -k temp.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign >/dev/null 2>&1

          if [ $? -eq 0 ]; then
            echo "‚úÖ Certificate imported successfully"
          else
            echo "‚ùå Failed to import certificate"
            rm -f developer_id_cert.p12
            exit 1
          fi

          rm -f developer_id_cert.p12

          security set-key-partition-list -S apple-tool:,apple: -s -k temp_password temp.keychain >/dev/null 2>&1
          echo "CODE_SIGNING_AVAILABLE=true" >> $GITHUB_ENV

      - name: Install system dependencies
        run: |
          if [ "${{ matrix.platform }}" = "macOS" ]; then
            echo "Installing macOS dependencies..."
          elif [ "${{ matrix.platform }}" = "linux" ]; then
            sudo apt-get update
            sudo apt-get install -y libasound2-dev libegl1 libjack-dev librtmidi-dev
          fi
        shell: bash

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install briefcase
          pip install -r requirements.txt
          if [ -f r2midi_client/requirements.txt ]; then 
            pip install -r r2midi_client/requirements.txt
          fi
        shell: bash

      - name: Update pyproject.toml
        run: |
          if [ "${BUNDLE_PREFIX}" != "com.r2midi" ]; then
            sed -i.bak "s|bundle = \"com\.r2midi\"|bundle = \"${BUNDLE_PREFIX}\"|g" pyproject.toml
          fi
          sed -i.bak "s|version = \"0\.1\.64\"|version = \"${APP_VERSION}\"|g" pyproject.toml
          sed -i.bak "s|author = \".*\"|author = \"${AUTHOR_NAME}\"|g" pyproject.toml
          sed -i.bak "s|author_email = \".*\"|author_email = \"${AUTHOR_EMAIL}\"|g" pyproject.toml
        shell: bash

      - name: Create production entitlements (macOS)
        if: matrix.platform == 'macOS'
        run: |
          mkdir -p production_entitlements
          cat > production_entitlements/server.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.app-sandbox</key>
              <false/>
              <key>com.apple.security.network.server</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.device.audio-input</key>
              <true/>
              <key>com.apple.security.files.user-selected.read-write</key>
              <true/>
          </dict>
          </plist>
          EOF

          # Create client entitlements (may have different requirements)
          cat > production_entitlements/client.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.app-sandbox</key>
              <false/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.device.audio-input</key>
              <true/>
              <key>com.apple.security.files.user-selected.read-write</key>
              <true/>
          </dict>
          </plist>
          EOF

          sed -i.bak 's|entitlements.plist|production_entitlements/server.plist|g' pyproject.toml

      - name: Download artifacts from build workflow
        uses: actions/download-artifact@v4
        with:
          name: stable-builds-${{ matrix.platform_name }}
          path: stable_builds/
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract build artifacts
        run: |
          echo "Extracting build artifacts for ${{ matrix.platform }}..."
          mkdir -p build/server/${{ matrix.platform }}/app
          mkdir -p build/r2midi-client/${{ matrix.platform }}/app

          if [ "${{ matrix.platform }}" = "macOS" ]; then
            # Extract macOS artifacts
            unzip -q "stable_builds/R2MIDI-Server-macos-stable-v${APP_VERSION}.zip" -d build/server/${{ matrix.platform }}/app/
            unzip -q "stable_builds/R2MIDI-Client-macos-stable-v${APP_VERSION}.zip" -d build/r2midi-client/${{ matrix.platform }}/app/
          elif [ "${{ matrix.platform }}" = "windows" ]; then
            # Extract Windows artifacts
            unzip -q "stable_builds/R2MIDI-Server-windows-stable-v${APP_VERSION}.zip" -d build/server/${{ matrix.platform }}/app/
            unzip -q "stable_builds/R2MIDI-Client-windows-stable-v${APP_VERSION}.zip" -d build/r2midi-client/${{ matrix.platform }}/app/
          else
            # Extract Linux artifacts
            mkdir -p temp_extract
            tar -xzf "stable_builds/R2MIDI-Server-linux-stable-v${APP_VERSION}.tar.gz" -C temp_extract
            cp -r temp_extract/* build/server/${{ matrix.platform }}/app/
            rm -rf temp_extract/*
            tar -xzf "stable_builds/R2MIDI-Client-linux-stable-v${APP_VERSION}.tar.gz" -C temp_extract
            cp -r temp_extract/* build/r2midi-client/${{ matrix.platform }}/app/
            rm -rf temp_extract
          fi

          ls -la build/server/${{ matrix.platform }}/app/
          ls -la build/r2midi-client/${{ matrix.platform }}/app/
        shell: bash

      - name: Sign applications (macOS only)
        if: matrix.platform == 'macOS'
        run: |
          if [ "$CODE_SIGNING_AVAILABLE" = "true" ]; then
            echo "Code signing macOS applications..."
            SIGNING_IDENTITY=$(security find-identity -v -p codesigning temp.keychain | grep "Developer ID Application" | head -1 | grep -o '"[^"]*"' | tr -d '"')

            if [ ! -z "$SIGNING_IDENTITY" ]; then
              for app in build/*/macOS/app/*.app; do
                if [ -d "$app" ]; then
                  echo "Signing: $app"
                  app_name=$(basename "$app")
                  if [[ "$app_name" == *"server"* ]]; then
                    entitlements_file="production_entitlements/server.plist"
                  else
                    entitlements_file="production_entitlements/client.plist"
                  fi
                  codesign --sign "$SIGNING_IDENTITY" --options runtime --entitlements "$entitlements_file" --timestamp --deep --force "$app"
                fi
              done
            fi
          fi

      - name: Package applications
        run: |
          echo "Packaging applications..."
          mkdir -p packaged

          if [ "${{ matrix.platform }}" = "macOS" ]; then
            # For macOS, we need to repackage after signing
            for app in build/*/macOS/app/*.app; do
              if [ -d "$app" ]; then
                app_dir=$(dirname "$app")
                app_name=$(basename "$app")
                echo "Packaging $app_name"

                # Determine if this is server or client
                if [[ "$app_name" == *"server"* || "$app_name" == *"Server"* ]]; then
                  output_name="R2MIDI-Server-macos-signed.zip"
                elif [[ "$app_name" == *"client"* || "$app_name" == *"Client"* ]]; then
                  output_name="R2MIDI-Client-macos-signed.zip"
                else
                  output_name="${app_name}.zip"
                fi

                # Create zip directly with the correct name
                cd "$app_dir"
                zip -r "$GITHUB_WORKSPACE/packaged/$output_name" "$app_name"
                cd "$GITHUB_WORKSPACE"
              fi
            done
          else
            echo "Using pre-packaged artifacts for ${{ matrix.platform }}"
            cp stable_builds/* packaged/
          fi

          echo "Packaged files:"
          ls -la packaged/
        shell: bash

      - name: Notarize macOS applications
        if: matrix.platform == 'macOS'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -n "$APPLE_ID" ] && [ -n "$APPLE_ID_PASSWORD" ] && [ -n "$APPLE_TEAM_ID" ]; then
            echo "üîê Starting notarization process..."

            # Mask sensitive values in logs
            echo "::add-mask::$APPLE_ID"
            echo "::add-mask::$APPLE_ID_PASSWORD"
            echo "::add-mask::$APPLE_TEAM_ID"

            for app in build/*/macOS/app/*.app; do
              if [ -d "$app" ]; then
                app_name=$(basename "$app" .app)
                zip_name="${app_name}-notarize.zip"

                echo "üì¶ Creating notarization ZIP for $app_name..."
                cd "$(dirname "$app")"
                zip -r "/tmp/$zip_name" "$(basename "$app")" >/dev/null 2>&1
                cd "$GITHUB_WORKSPACE"

                echo "üöÄ Submitting $app_name for notarization..."

                # Create a log file for notarization output
                notarization_log="/tmp/${app_name}_notarization.log"

                # Submit for notarization with output redirected to log file
                xcrun notarytool submit "/tmp/$zip_name" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_ID_PASSWORD" \
                  --team-id "$APPLE_TEAM_ID" \
                  --wait --timeout 20m > "$notarization_log" 2>&1

                if [ $? -eq 0 ]; then
                  echo "‚úÖ $app_name notarized successfully"
                  echo "üîó Stapling notarization to app..."

                  # Create a log file for stapling output
                  stapling_log="/tmp/${app_name}_stapling.log"

                  # Try stapling with verbose output to log file
                  xcrun stapler staple -v "$app" > "$stapling_log" 2>&1
                  staple_result=$?

                  if [ $staple_result -eq 0 ]; then
                    echo "‚úÖ Notarization stapled to $app_name"
                  else
                    echo "‚ö†Ô∏è Failed to staple notarization to $app_name (exit code: $staple_result)"
                    echo "‚ö†Ô∏è Stapling log (last 10 lines):"
                    tail -n 10 "$stapling_log" || echo "No stapling log available"

                    # Try alternative stapling approach
                    echo "üîÑ Trying alternative stapling approach..."
                    xcrun stapler staple -v "$app" --no-progress > "${stapling_log}_alt" 2>&1

                    if [ $? -eq 0 ]; then
                      echo "‚úÖ Alternative stapling succeeded for $app_name"
                    else
                      echo "‚ùå All stapling attempts failed. App is notarized but not stapled."
                      echo "   Users may need to be online for the first launch."
                    fi
                  fi
                else
                  echo "‚ùå Notarization failed for $app_name"
                  echo "‚ùå Notarization log (last 10 lines):"
                  tail -n 10 "$notarization_log" || echo "No notarization log available"
                fi

                # Clean up
                rm -f "/tmp/$zip_name"
                rm -f "$notarization_log" "$stapling_log" "${stapling_log}_alt" 2>/dev/null || true
              fi
            done
          else
            echo "‚ö†Ô∏è Notarization skipped (missing credentials)"
          fi

      - name: Prepare release files
        run: |
          mkdir -p release_files

          # Simply copy the packaged files to release_files directory
          if [ -d "packaged" ]; then
            echo "Copying packaged files to release_files..."

            # For macOS, the files are already named correctly
            if [ "${{ matrix.platform }}" = "macOS" ]; then
              cp packaged/R2MIDI-*-macos-signed.zip release_files/ 2>/dev/null || true

            # For Windows, remove "-signed" suffix
            elif [ "${{ matrix.platform }}" = "windows" ]; then
              for zip_file in packaged/*windows*.zip; do
                if [ -f "$zip_file" ]; then
                  if [[ "$zip_file" == *"Server"* ]]; then
                    cp "$zip_file" "release_files/R2MIDI-Server-windows.zip"
                  elif [[ "$zip_file" == *"Client"* ]]; then
                    cp "$zip_file" "release_files/R2MIDI-Client-windows.zip"
                  fi
                fi
              done

            # For Linux, remove "-signed" suffix
            else
              for tar_file in packaged/*linux*.tar.gz; do
                if [ -f "$tar_file" ]; then
                  if [[ "$tar_file" == *"Server"* ]]; then
                    cp "$tar_file" "release_files/R2MIDI-Server-linux.tar.gz"
                  elif [[ "$tar_file" == *"Client"* ]]; then
                    cp "$tar_file" "release_files/R2MIDI-Client-linux.tar.gz"
                  fi
                fi
              done
            fi
          else
            echo "Warning: packaged directory not found, using fallback method"

            # Fallback methods if packaged directory doesn't exist
            if [ "${{ matrix.platform }}" = "macOS" ]; then
              if [ -d "build/server/macOS/app" ]; then
                cd build/server/macOS/app
                zip -r "$GITHUB_WORKSPACE/release_files/R2MIDI-Server-macos-signed.zip" *.app
                cd "$GITHUB_WORKSPACE"
              fi
              if [ -d "build/r2midi-client/macOS/app" ]; then
                cd build/r2midi-client/macOS/app
                zip -r "$GITHUB_WORKSPACE/release_files/R2MIDI-Client-macos-signed.zip" *.app
                cd "$GITHUB_WORKSPACE"
              fi
            elif [ "${{ matrix.platform }}" = "windows" ]; then
              if [ -d "build/server/windows/app" ]; then
                # Use PowerShell for Windows zip operations
                echo "Using PowerShell to create Windows zip files"
                powershell -Command "Compress-Archive -Path 'build/server/windows/app/*' -DestinationPath 'release_files/R2MIDI-Server-windows.zip' -Force"
              fi
              if [ -d "build/r2midi-client/windows/app" ]; then
                powershell -Command "Compress-Archive -Path 'build/r2midi-client/windows/app/*' -DestinationPath 'release_files/R2MIDI-Client-windows.zip' -Force"
              fi
            else  # Linux
              if [ -d "build/server/linux/system" ]; then
                tar -czf "release_files/R2MIDI-Server-linux.tar.gz" -C build/server/linux/system .
              fi
              if [ -d "build/r2midi-client/linux/system" ]; then
                tar -czf "release_files/R2MIDI-Client-linux.tar.gz" -C build/r2midi-client/linux/system .
              fi
            fi
          fi

          echo "Release files prepared:"
          ls -la release_files/
        shell: bash

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-release-${{ matrix.platform_name }}
          path: release_files/*
          retention-days: 30

      - name: Cleanup keychain (macOS)
        if: always() && matrix.platform == 'macOS'
        run: |
          security delete-keychain temp.keychain || true

  app-store-submission:
    needs: [check-build-success, code-sign-and-package]
    if: needs.check-build-success.outputs.should_app_store == 'true'
    runs-on: macos-14
    environment: app-store

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Fix submodules
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git submodule deinit -f server/midi-presets || true
          rm -rf .git/modules/server/midi-presets || true
          git rm -rf server/midi-presets || true
          git submodule add https://github.com/tirans/midi-presets.git server/midi-presets
          git submodule init
          git submodule update --init --recursive
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Configure App Store metadata
        env:
          BUNDLE_PREFIX: ${{ secrets.APP_BUNDLE_ID_PREFIX }}
          SERVER_NAME: ${{ secrets.APP_DISPLAY_NAME_SERVER }}
          CLIENT_NAME: ${{ secrets.APP_DISPLAY_NAME_CLIENT }}
          AUTHOR_NAME: ${{ secrets.APP_AUTHOR_NAME }}
          AUTHOR_EMAIL: ${{ secrets.APP_AUTHOR_EMAIL }}
        run: |
          echo "BUNDLE_PREFIX=${BUNDLE_PREFIX:-com.r2midi}" >> $GITHUB_ENV
          echo "SERVER_NAME=${SERVER_NAME:-R2MIDI Server}" >> $GITHUB_ENV
          echo "CLIENT_NAME=${CLIENT_NAME:-R2MIDI Client}" >> $GITHUB_ENV
          echo "AUTHOR_NAME=${AUTHOR_NAME:-R2MIDI Team}" >> $GITHUB_ENV
          echo "AUTHOR_EMAIL=${AUTHOR_EMAIL:-tiran@tirans.com}" >> $GITHUB_ENV

          VERSION=$(grep -o '__version__ = "[^"]*"' server/version.py | cut -d'"' -f2)
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Import App Store certificates
        env:
          APPLE_APP_STORE_CERTIFICATE_P12: ${{ secrets.APPLE_APP_STORE_CERTIFICATE_P12 }}
          APPLE_APP_STORE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_APP_STORE_CERTIFICATE_PASSWORD }}
        run: |
          if [ -z "$APPLE_APP_STORE_CERTIFICATE_P12" ]; then
            echo "‚ùå No App Store signing certificates provided"
            exit 1
          fi

          # Mask sensitive values in logs
          echo "::add-mask::$APPLE_APP_STORE_CERTIFICATE_PASSWORD"

          security create-keychain -p temp_password app_store.keychain
          security default-keychain -s app_store.keychain
          security unlock-keychain -p temp_password app_store.keychain

          # Import certificate with error handling
          echo "$APPLE_APP_STORE_CERTIFICATE_P12" | base64 --decode > app_store_cert.p12
          security import app_store_cert.p12 -k app_store.keychain -P "$APPLE_APP_STORE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign >/dev/null 2>&1

          if [ $? -eq 0 ]; then
            echo "‚úÖ App Store certificate imported successfully"
          else
            echo "‚ùå Failed to import App Store certificate"
            rm -f app_store_cert.p12
            exit 1
          fi

          rm -f app_store_cert.p12

          security set-key-partition-list -S apple-tool:,apple: -s -k temp_password app_store.keychain >/dev/null 2>&1
          echo "APP_STORE_SIGNING_AVAILABLE=true" >> $GITHUB_ENV

      - name: Setup App Store Connect API key
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
        run: |
          # Mask sensitive values
          echo "::add-mask::$APP_STORE_CONNECT_API_KEY"
          echo "::add-mask::$APP_STORE_CONNECT_ISSUER_ID"
          echo "::add-mask::$APP_STORE_CONNECT_KEY_ID"

          mkdir -p ~/.appstoreconnect/private_keys
          echo "$APP_STORE_CONNECT_API_KEY" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8

          # Set environment variables without exposing sensitive data
          echo "API_KEY_CONFIGURED=true" >> $GITHUB_ENV
          echo "ISSUER_ID=${APP_STORE_CONNECT_ISSUER_ID}" >> $GITHUB_ENV
          echo "KEY_ID=${APP_STORE_CONNECT_KEY_ID}" >> $GITHUB_ENV

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install briefcase
          pip install -r requirements.txt
          if [ -f r2midi_client/requirements.txt ]; then 
            pip install -r r2midi_client/requirements.txt
          fi

      - name: Update pyproject.toml for App Store
        run: |
          # Create App Store specific configuration
          cp pyproject.toml pyproject_appstore.toml

          # Update with App Store configuration
          if [ "${BUNDLE_PREFIX}" != "com.r2midi" ]; then
            sed -i.bak "s|bundle = \"com\.r2midi\"|bundle = \"${BUNDLE_PREFIX}\"|g" pyproject_appstore.toml
          fi
          sed -i.bak "s|version = \"0\.1\.64\"|version = \"${APP_VERSION}\"|g" pyproject_appstore.toml
          sed -i.bak "s|author = \".*\"|author = \"${AUTHOR_NAME}\"|g" pyproject_appstore.toml
          sed -i.bak "s|author_email = \".*\"|author_email = \"${AUTHOR_EMAIL}\"|g" pyproject_appstore.toml

          # Update macOS configuration for App Store
          sed -i.bak 's|codesign_identity = "Developer ID Application"|codesign_identity = "3rd Party Mac Developer Application"|g' pyproject_appstore.toml

      - name: Create App Store entitlements
        run: |
          mkdir -p app_store_entitlements

          # App Store entitlements are more restrictive
          cat > app_store_entitlements/server.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.app-sandbox</key>
              <true/>
              <key>com.apple.security.network.server</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.device.audio-input</key>
              <true/>
              <key>com.apple.security.files.user-selected.read-write</key>
              <true/>
              <key>com.apple.security.files.downloads.read-write</key>
              <true/>
          </dict>
          </plist>
          EOF

          cat > app_store_entitlements/client.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.app-sandbox</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.device.audio-input</key>
              <true/>
              <key>com.apple.security.files.user-selected.read-write</key>
              <true/>
              <key>com.apple.security.files.downloads.read-write</key>
              <true/>
          </dict>
          </plist>
          EOF

          # Update pyproject.toml to use App Store entitlements
          sed -i.bak 's|entitlements.plist|app_store_entitlements/server.plist|g' pyproject_appstore.toml

      - name: Download artifacts from build workflow
        uses: actions/download-artifact@v4
        with:
          name: stable-builds-macos
          path: stable_builds/
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract build artifacts for App Store
        run: |
          echo "Extracting macOS build artifacts for App Store..."
          mkdir -p build/server/macOS/app
          mkdir -p build/r2midi-client/macOS/app

          # Extract macOS artifacts
          VERSION=$(grep -o '__version__ = "[^"]*"' server/version.py | cut -d'"' -f2)
          unzip -q "stable_builds/R2MIDI-Server-macos-stable-v${VERSION}.zip" -d build/server/macOS/app/
          unzip -q "stable_builds/R2MIDI-Client-macos-stable-v${VERSION}.zip" -d build/r2midi-client/macOS/app/

          echo "Extracted App Store artifacts:"
          ls -la build/server/macOS/app/
          ls -la build/r2midi-client/macOS/app/
        shell: bash

      - name: Prepare for App Store signing
        run: |
          # Use the App Store specific configuration
          export PYPROJECT_PATH="pyproject_appstore.toml"
          echo "üè™ Preparing applications for App Store signing..."

          # No need to create and build again, just prepare the existing apps for signing

      - name: Sign for App Store
        run: |
          APP_STORE_IDENTITY=$(security find-identity -v -p codesigning app_store.keychain | grep "3rd Party Mac Developer Application" | head -1 | grep -o '"[^"]*"' | tr -d '"')
          INSTALLER_IDENTITY=$(security find-identity -v -p codesigning app_store.keychain | grep "3rd Party Mac Developer Installer" | head -1 | grep -o '"[^"]*"' | tr -d '"')

          if [ -z "$APP_STORE_IDENTITY" ]; then
            echo "‚ùå No App Store signing identity found"
            exit 1
          fi

          echo "üîê Signing applications for App Store with: $APP_STORE_IDENTITY"

          for app in build/*/macOS/app/*.app; do
            if [ -d "$app" ]; then
              app_name=$(basename "$app")
              echo "Signing: $app_name"

              if [[ "$app_name" == *"server"* ]]; then
                entitlements_file="app_store_entitlements/server.plist"
              else
                entitlements_file="app_store_entitlements/client.plist"
              fi

              codesign --sign "$APP_STORE_IDENTITY" --entitlements "$entitlements_file" --options runtime --timestamp --deep --force "$app"

              # Verify signing
              codesign --verify --verbose "$app"
            fi
          done

      - name: Create App Store packages
        run: |
          INSTALLER_IDENTITY=$(security find-identity -v -p codesigning app_store.keychain | grep "3rd Party Mac Developer Installer" | head -1 | grep -o '"[^"]*"' | tr -d '"')

          mkdir -p app_store_packages

          for app in build/*/macOS/app/*.app; do
            if [ -d "$app" ]; then
              app_name=$(basename "$app" .app)
              pkg_name="${app_name}-${APP_VERSION}.pkg"

              echo "üì¶ Creating App Store package: $pkg_name"

              if [ -n "$INSTALLER_IDENTITY" ]; then
                productbuild --component "$app" /Applications \
                  --sign "$INSTALLER_IDENTITY" \
                  "app_store_packages/$pkg_name"
              else
                echo "‚ö†Ô∏è No installer identity found, creating unsigned package"
                productbuild --component "$app" /Applications \
                  "app_store_packages/$pkg_name"
              fi
            fi
          done

          ls -la app_store_packages/

      - name: Submit to App Store Connect
        env:
          ISSUER_ID: ${{ env.ISSUER_ID }}
          KEY_ID: ${{ env.KEY_ID }}
        run: |
          if [ "${{ secrets.ENABLE_APP_STORE_SUBMISSION }}" != "true" ]; then
            echo "üè™ App Store submission disabled (set ENABLE_APP_STORE_SUBMISSION=true to enable)"
            exit 0
          fi

          # Construct API key path securely
          API_KEY_PATH="~/.appstoreconnect/private_keys/AuthKey_${KEY_ID}.p8"

          for pkg in app_store_packages/*.pkg; do
            if [ -f "$pkg" ]; then
              pkg_name=$(basename "$pkg")
              echo "üöÄ Submitting $pkg_name to App Store Connect..."

              # Submit with suppressed verbose output to prevent key exposure
              xcrun altool --upload-app \
                --type osx \
                --file "$pkg" \
                --apiKey "$KEY_ID" \
                --apiIssuer "$ISSUER_ID" \
                --show-progress 2>/dev/null

              if [ $? -eq 0 ]; then
                echo "‚úÖ $pkg_name submitted successfully"
              else
                echo "‚ùå Failed to submit $pkg_name"
                exit 1
              fi
            fi
          done

          echo "üéâ All packages submitted to App Store Connect!"
          echo "üì± Next steps:"
          echo "  1. Check App Store Connect for processing status"
          echo "  2. Complete app metadata and screenshots"
          echo "  3. Submit for review when ready"

      - name: Upload App Store packages as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: app-store-packages
          path: app_store_packages/*.pkg
          retention-days: 30

      - name: Cleanup App Store keychain
        if: always()
        run: |
          rm -rf ~/.appstoreconnect
          security delete-keychain app_store.keychain || true

  publish-production-release:
    needs: [code-sign-and-package, check-build-success]
    runs-on: ubuntu-latest
    if: needs.check-build-success.outputs.should_release == 'true' || (github.event.workflow_run.conclusion == 'failure' && needs.check-build-success.outputs.should_release == 'true')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Get version
        id: get_info
        run: |
          VERSION=$(grep -o '__version__ = "[^"]*"' server/version.py | cut -d'"' -f2)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all production artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: production-release-*
          path: combined_production_files
          merge-multiple: true

      - name: Download App Store packages (if available)
        if: needs.check-build-success.outputs.should_app_store == 'true'
        uses: actions/download-artifact@v4
        with:
          name: app-store-packages
          path: combined_production_files
        continue-on-error: true

      - name: Create Production Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.get_info.outputs.version }}
          name: R2MIDI v${{ steps.get_info.outputs.version }}${{ needs.check-build-success.outputs.build_status == 'failure' && ' (Failed Build)' || '' }}
          files: combined_production_files/*
          token: ${{ secrets.GITHUB_TOKEN }}
          body: |
            ## üöÄ R2MIDI v${{ steps.get_info.outputs.version }} - Production Release${{ needs.check-build-success.outputs.build_status == 'failure' && ' (Failed Build)' || '' }}

            ${{ needs.check-build-success.outputs.build_status == 'failure' && '‚ö†Ô∏è **WARNING: This release was created from a failed build. It may contain bugs or incomplete features.** ‚ö†Ô∏è\n\n' || '' }}**Official production release with signed applications for macOS.**

            ### üì¶ Downloads

            #### üçé macOS (Code Signed & Notarized)
            - **R2MIDI-Server-macos-signed.zip** - R2MIDI Server (.app bundle)
            - **R2MIDI-Client-macos-signed.zip** - R2MIDI Client (.app bundle)

            #### ü™ü Windows (Unsigned)
            - **R2MIDI-Server-windows.zip** - R2MIDI Server
            - **R2MIDI-Client-windows.zip** - R2MIDI Client
            - ‚ö†Ô∏è Windows builds are unsigned and may show security warnings

            #### üêß Linux (Ready to Use)
            - **R2MIDI-Server-linux.tar.gz** - R2MIDI Server
            - **R2MIDI-Client-linux.tar.gz** - R2MIDI Client

            ${{ needs.check-build-success.outputs.should_app_store == 'true' && '#### üè™ Mac App Store\n- **R2MIDI Server** and **R2MIDI Client** submitted to App Store\n- Check App Store Connect for review status\n- App Store packages also available as release artifacts\n' || '#### üè™ Mac App Store\n- App Store submission not configured\n- Set up App Store Connect API key to enable automatic submission\n' }}

            ### üìã Installation

            #### macOS ‚úÖ
            1. **Direct Download**: Download and extract the .zip file, move to Applications
            2. **Mac App Store**: Search for "R2MIDI" in the App Store (if approved)
            3. Right-click and select "Open" on first launch for direct downloads

            #### Windows ‚ö†Ô∏è
            1. Download and extract the .zip file
            2. You may need to allow the app through Windows Defender
            3. Right-click the .exe and select "Run as administrator" if needed

            #### Linux ‚úÖ
            ```bash
            tar -xzf R2MIDI-*-linux.tar.gz
            chmod +x r2midi-*
            ./r2midi-server  # or ./r2midi-client
            ```

            ### ‚ú® Features
            - üîí macOS applications are fully code signed and notarized
            - üêß Native Linux builds ready to use
            - ü™ü Windows builds (unsigned - security warnings expected)
            - üè™ Automatic App Store submission (when configured)
            - üì¶ Improved packaging and installation

            ### üè™ App Store Status
            ${{ needs.check-build-success.outputs.should_app_store == 'true' && '‚úÖ **Submitted to Mac App Store** - Check App Store Connect for review status' || '‚ö†Ô∏è **App Store submission disabled** - Configure APP_STORE_CONNECT_API_KEY to enable' }}

            ### ‚ö†Ô∏è Security Notes
            - **macOS**: Fully signed and notarized - no security warnings
            - **Windows**: Unsigned - expect security warnings from Windows Defender
            - **Linux**: No signing required

            For documentation and support, visit [GitHub](https://github.com/tirans/r2midi).